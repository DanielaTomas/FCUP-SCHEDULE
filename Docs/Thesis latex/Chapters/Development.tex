\pretocmd{\chapter}{\glsresetall}{}{}

% Development

% Main chapter title
%\chapter[toc version]{doc version}
\chapter{Development}

% Short version of the title for the header
%\chaptermark{version for header}

% Chapter Label
% For referencing this chapter elsewhere, use \ref{ChapterTemplate}
\label{Development}

This chapter describes the development of the timetable system, formulating the problem, discussing the implementation of the\ac{mcts} and\ac{hc} hybrid approach, detailing the design choices, and algorithmic improvements made throughout the project. 

The source code for the hybrid timetabling system is available at \url{https://github.com/DanielaTomas/FCUP-SCHEDULE/tree/main/schedule-backend/FlaskAPI/mcts/}. The repository includes detailed instructions for installation, configuration, and running the system.

\section{Problem Formulation}

The formulation presented is based on the model proposed in the\ac{itc-2007} track 3. The entities in the problem are listed below:

\begin{itemize}
	\item \textbf{Periods, \(P = \{P_0, P_1, ..., P_|_P_|_-_1\}\):} Days are divided into fixed timeslots, with periods consisting of a day and a timeslot.

		%\unsure[inline]{In the previous work, there is no periods. There are weekdays, a start time and an end time. For now, in the current approach, an event is only associated with a period of one hour and without any link to previous work. If I implement this concept to previous work, an event should be assigned to one or more half-hour periods.}

	\item \textbf{Rooms, \(R = \{R_0, R_1, ..., R_|_R_|_-_1\}\):} Each room has a capacity and a type.
		\begin{itemize}
			%\item Occupation (the room may be utilized for non-teaching reasons, such as exams) (TODO)
			\item Capacity (number of seats)
			%\item Type (TODO)
		\end{itemize}

	\item \textbf{Lecturers, \(L = \{L_0, L_1, ..., L_|_L_|_-_1\}\):} We assume lecturers are pre-assigned to events.
		\begin{itemize}
			%\item Office
			\item Availability
			%\item Restriction (availability and TODO: preferences for periods)
		\end{itemize}

	\item \textbf{Events, \(E = \{E_0, E_1, ..., E_|_E_|_-_1\}\):} Represent the events to be scheduled (usually lectures). Each event has associated the following attributes:
%		\begin{multicols}{2}
%		\textbf{Previous work:}
%		\begin{itemize}
%			\item Start and end time
%			\item Weekday
%			\item Duration
%			\item Lecturer
%			\item Room
%		\end{itemize}
%		\columnbreak
%		\textbf{TODO: adicionar ao trabalho anterior?}
		\begin{itemize}
        		\item Capacity (number of students);
        		\item Number of lectures;
        		\item Minimum working days (days over which the events of the same course should be spread);
        		\item Available periods;
        		\item Priority;
        		\item Lecturer
		\end{itemize}
%		\end{multicols} 

	\item \textbf{Blocks, \(B = \{B_0, B_1, ..., B_|_B_|_-_1\}\):} A block may represent a group of related events. Usually represents all events from the same curriculum, which is a set of courses in a study program.
\end{itemize}


\subsection{Assignment Attributes}

Although not intrinsic properties of events, the following elements are essential in the assignment process:

\begin{itemize}
	\item \textbf{Period (day, timeslot):} Each event is to be scheduled into exactly one period.
	\item \textbf{Room:} Each event must be assigned to a room that satisfies its capacity.
\end{itemize}


\subsection{Constraints}

There are several hard and soft constraints that affect the creation of timetables. The following hard and soft constraints were selected, drawing inspiration from those of\ac{itc-2007}:

\textbf{Hard constraints:}

\begin{itemize}
	\item \textbf{H1:} Events belonging to the same course must be scheduled and must be assigned to distinct periods.
	\item \textbf{H2:} Two events can be scheduled in the same room, but only if they are in different periods.
	\item \textbf{H3:} Events of the same curricula, or taught by the same lecturer, must be scheduled in different periods.
	\item \textbf{H4:} If a lecturer is unavailable in a given period, then no events can be taught by this lecturer in that period.
%	\item \textbf{TODO H5:} If a room is unavailable in a given period, then no events can be scheduled in that period.
%	\item \textbf{TODO H6:} Lecturers and students must have a free lunch period.
\end{itemize}

\textbf{Soft constraints:}

\begin{itemize}
	\item \textbf{S1:} Events of the same course should be spread into the given minimum number of days.
	\item \textbf{S2:} Events belonging to the same curriculum should be in consecutive periods.
	\item \textbf{S3:} The capacity of the room should be higher or equal than the capacity of the event.
	\item \textbf{S4:} All events of a course should be given in the same room.
\end{itemize}

The problem is typically defined as a minimization problem, with the algorithm attempting to minimize soft constraint violations while strictly adhering to hard constraints. However, in this implementation, the signals of the evaluation functions were inverted. As a result, the algorithm is designed as a maximization problem, where higher scores indicate better solutions.

\section{Monte Carlo Tree Search}

%This section describes the key algorithmic components of the system, particularly the hybrid\ac{mcts} with\ac{hc} approach.

%(...)

\subsection{Search Space}

The search space, \(S\),  for this problem is large as it involves a product of all possible event-period-room combinations: \[S = E \times P  \times R,\] where \(E\) is the set of events, \(P\) is the set of periods (day, timeslot), and \(R\) is the set of rooms.

To reduce the search space, unavailable periods and unavailable rooms for a chosen period are discarded immediately in the\ac{mcts} \(expansion\) phase.

\subsection{\ac{mcts} Tree}

\begin{figure}
      \centering
      \includegraphics[width=0.7\columnwidth]{Development/MCTS_tree.jpg}
      \caption[MCTS tree]
      {MCTS tree}
      \label{fig:mcts_tree}
\end{figure}

Figure \ref{fig:mcts_tree} illustrates the basic structure of the\ac{mcts} tree. The root represents the initial state, where no events have been assigned. The first level corresponds to assigning the first event, \(E_0\), to various \(P\) and \(R\). Each child node represents a specific assignment (\((E_0,P_0,R_0),...,(E_0,P_|_P_|_-_1,R_|_R_|_-_1)\)). Subsequent levels correspond to the sequential assignment of events \(E_1, E_2, ..., E_|_E_|_-_1\).

\subsubsection{Tree Nodes}

A node is composed of the following attributes:

\begin{itemize}
%\item A \textbf{path} is a dictionary that represents the sequence of actions leading to a node. The root is the only node that has an empty path.

\item A \textbf{parent} is a reference to the parent node, allowing the tree structure to be navigated upwards. The root is the only node that does not have a parent.

\item \textbf{Children} is initialized as an empty list at first but will later hold references to the node's child nodes. 

\item The \textbf{expansion limit} specifies the maximum number of children that a node can have, which helps control the expansion process by limiting dynamically how many possible event-period-room assignments can be explored from that node. The expansion limit is calculated based on the number of available rooms per period for the next event. A value of zero indicates that the node cannot be expanded further.

\item \textbf{Visits} is initialized to 0, tracking the number of times a node has been visited.

\item The \textbf{hard and soft scores} are both initialized to 0, representing the cumulative back-propagated hard and soft scores for a node, which are used to evaluate the quality of the node's state.

\item The \textbf{hard and soft simulation results} represent the result of a single simulation performed for a node. These values are used as \(best\_penalty\_n\) in the normalization equation (section \ref{sec:normalization} Equation \ref{normalization_formula}) to scale results between 0 and 1.
\end{itemize}

\subsection{Events Allocation}

Events are sorted in advance so that the most difficult event to place is placed first in the tree. We propose to determine the priority of an event (Equation \ref{priority}) based on:

\begin{itemize}
\item The difference between the number of lectures and minimum working days to prioritize events with more lectures spread over fewer days;
\item The number of available periods, as having fewer available periods indicates more scheduling restrictions;
\item The capacity of an event, which implies that events with greater capacity have higher priority;
\item The number of curricula in which the event is, as events that appear in more curricula are more difficult to allocate.
\end{itemize}

If two or more events have the same priority score, they are ordered randomly.

The order of the events has a significant impact on the results. We tried other alternatives, but this one worked the best. 

\begin{equation}
  \begin{aligned}
	Priority = (\#lectures - \#min\_working\_days) \cdot 4 \\
	           - \#available\_periods \cdot 3 \\
	          + capacity \cdot 2 \\
	          + \#blocks\label{priority}
  \end{aligned}
\end{equation}

%I have tried other priority formulas...

\subsection{Periods and Rooms Allocation}

Initially, our approach to allocating periods and rooms in the\ac{mcts} tree followed a structured sequence. This method aimed to explore all possible (period, room) combinations based on the number of children of the node being expanded. However, as we progressed, this approach started to fail when the availability of rooms varied across different periods, leading to duplicate assignments. 

To overcome these limitations more robustly, a refined approach was then developed. Instead of computing the (period, room) combinations via index math as we first thought, we pre-compute all valid combinations once. This method produces a flat list of unique and valid assignments.

Moreover, periods that are less frequently available across all events are given higher priority. In this way, the algorithm reduces the risk of future conflicts, guiding the tree toward less constrained decisions early. For each period, available rooms are also sorted by how closely their capacity matches the event’s requirements. This reduces wasted space and improves flexibility in room usage.

\subsection{Methodology}\label{sec:methodology}

The\ac{mcts} algorithm consists of four phases: \(selection\), \(expansion\), \(simulation\), and \(backpropagation\). Each phase plays a critical role in exploring the search space and updating the tree structure with the simulation outcomes. Figure \ref{fig:mcts_steps} provides a high-level overview of these four phases in the\ac{mcts} process.

\begin{figure}[H]
      \centering
      \includegraphics[width=1.1\columnwidth]{Development/MCTS_Steps.jpg}
      \caption[MCTS steps]
      {MCTS steps}
      \label{fig:mcts_steps}
\end{figure}

\subsubsection{Selection}

The \(selection\) phase (Algorithm \ref{selection}) begins at the root and traverses the tree by iteratively selecting the best child nodes according to Equation \ref{uct_formula} until a terminal (leaf) node is reached. A node is considered terminal if it cannot be expanded further (i.e., its expansion limit is zero). Conversely, a node is deemed fully expanded if either its expansion limit is zero or if the number of its children equals its expansion limit. If the traversal encounters a node that is not fully expanded, the selection stops, and that node is selected for further expansion.

The best child node (Algorithm \ref{best_child}) is determined by applying the\ac{uct} formula (Equation \ref{uct_formula}). However, since the problem has two goals, minimizing hard constraints' violations first and then the soft constraints, the\ac{uct} formula was applied differently. Initially, the algorithm computes the weights for each child node using the hard score. Among the children with the highest hard score, the weights are recalculated based on the soft score. The child node with the highest weight in this second calculation is selected as the best child. %However, if all of a node's children have reached their expansion limit, the algorithm backtracks: if the current node has a parent, the current node's expansion limit is set to zero, and it moves up to the parent. Reaching the root indicates that the entire tree is fully expanded.

\begin{algorithm}
\caption{Selection}\label{selection}
\begin{algorithmic}[1]
\Function{SELECTION}{}
	\State Start from the root node
	\While{current node is not terminal}
			\If{current node has unexplored children}
				\State break
			\Else
				\If{no valid children remaining}
					\State \Return False \Comment Fully expanded tree
            			\Else
                			\State BEST\_CHILD(children, c\_param)
				\EndIf
			\EndIf
	\EndWhile
	\State Store the selected node for expansion
	\State \Return True
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Best Child}\label{best_child}
\begin{algorithmic}[1]
\Function{BEST\_CHILD}{children, c\_param = 1.4}
    \State Evaluate candidates based on hard constraints using\ac{uct} (Equation \ref{uct_formula})
    \State Filter those with the highest hard score
    \State Among them, evaluate based on soft constraints using\ac{uct} (Equation \ref{uct_formula})
    \State \Return child with the highest overall score
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Expansion}

The \(expansion\) phase (Algorithm \ref{expansion}) is responsible for expanding the node previously selected by assigning the next event to a valid (period, room) combination and creating a corresponding child node.

The next event to schedule is determined by the depth of the current node. For the selected event, the algorithm gathers the available (weekday, timeslot) combinations and filters suitable rooms for each period (Algorithm \ref{find_available_rooms}), based on the event’s capacity requirements and current room occupation.

A list of valid (period, room) combinations is generated. If no such combinations exist or the node has already been expanded for all possibilities, expansion is terminated, and the node is marked as fully expanded.  

A combination is selected based on the number of already-expanded children. %A new path is constructed by assigning the selected period and room to the event.

Before proceeding, the algorithm evaluates the partial timetable (i.e., the new child) against a global hard penalty threshold. Since the problem is formulated as a maximization problem (i.e., higher hard scores indicate fewer constraint violations), this threshold defines the minimum acceptable hard score for a solution. If the resulting hard score for the partial timetable with the new assignment is lower than the threshold, the expansion stops for that branch. However, if the penalty exceeds or equals the threshold, the node remains in the tree. This pruning strategy was introduced to focus computational effort on promising and potentially feasible solutions. Notably, we use a threshold rather than immediately discarding all infeasible nodes because, in real-world timetabling problems, a fully feasible solution might not always be possible. Completely eliminating infeasible nodes would make the algorithm unsuitable for hard instances, as it would prevent the search from distinguishing between degrees of infeasibility.

If the expansion continues, the algorithm calculates the number of valid (period, room) combinations for the next event. This value is stored as the child’s expansion\_limit to guide future branching.

Finally, a new child node is created with the updated path and expansion limit. This new node is added to the tree, and the current node is updated to this newly created node.

\begin{algorithm}
\caption{Expansion}\label{expansion}
\begin{algorithmic}[1]
\Function{EXPANSION}{}
	\State Identify the next event based on current node’s depth
	\State FIND\_AVAILABLE\_ROOMS(...) \Comment Retrieve available periods and corresponding valid rooms 
\\
	\If{no valid (period, room) combinations exist}
		\State Mark current node as fully expanded
		\State \Return False
	\EndIf
\\
	\State Select the next untried (period, room) combination
	\State Assign this to the event
\\
    \State Evaluate partial assignment's hard score
\\
    \If{hard score is below threshold}
		\State Pruning
		\State \Return False
	\EndIf
\\
	\State Create a new child node
	\State Add the child node to the current node’s children
	\State Update current node to the newly created child
	\State \Return True    
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Find Available Rooms}\label{find_available_rooms}
\begin{algorithmic}[1]
\Function{FIND\_AVAILABLE\_ROOMS}{event\_capacity, rooms, events, available\_periods}
    \State Initialize period\_room\_availability with all rooms available per period
    \For{each event already scheduled}
        \State Remove occupied rooms from the corresponding periods
    \EndFor
\\
    \State Identify rooms that satisfy the event's capacity requirement
\\
    \For{each available period}
        \If{rooms are still available}
            \State Find intersection between available and suitable rooms
            \If{intersection is not empty}
                \State Sort intersected rooms by (room capacity - event capacity)
            \Else
                \State Sort available rooms by $|$room capacity - event capacity$|$
            \EndIf
            \State Update period\_room\_availability with sorted list
        \EndIf
    \EndFor
\\
    \State \Return period\_room\_availability
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Simulation}

The \(simulation\) phase estimates the value of each action, in this case, each event allocation, which will guide the selection and expansion steps in future iterations. 

A random event allocation approach was initially explored but produced suboptimal results. Therefore, a more structured method was implemented.

The \(simulation\) function (Algorithm \ref{simulation}) starts by retrieving the events already scheduled. It then sorts the remaining events, i.e., events that have not been assigned yet, based on two criteria:
\begin{enumerate}
\item Whether they were previously unassigned in prior simulations, ensuring that more critical events are allocated first.
\item Their priority (Equation \ref{priority}), to prioritize harder-to-schedule events.
\end{enumerate}

For each unvisited event, the algorithm searches for the best available period and room combination (Algorithm \ref{find_best_room_and_period}). This involves iterating through all the available periods and rooms, calculating the hard and soft penalties for each combination. During the calculation of the soft penalties, the importance of compactness (i.e., minimizing the time between related events) is adjusted, with a higher weight applied as the algorithm progresses, encouraging more compact schedules in later stages. The combination with no hard penalties and the lowest soft penalty score is selected as the best option. If multiple equally optimal choices exist, one is randomly selected. The event is then updated with the selected room, weekday, and timeslot. If no valid assignment is found, the event is left unassigned and its priority is increased for future simulations.

After scheduling all events, the algorithm evaluates the overall timetable, computing its hard and soft penalty scores. The best and worst penalty scores are then updated based on these results. If a new best solution is found, the timetable is saved to a file. Moreover, if a new best solution is found and the hard penalty is zero, indicating a feasible solution, the\ac{hc} algorithm (section \ref{hill_climbing_section} Algorithm \ref{run_hill_climbing}) is used to further optimize the timetable.

\begin{algorithm}
\caption{Simulation}\label{simulation}
\begin{algorithmic}[1]
\Function{SIMULATION}{start\_time, time\_limit}
    \State Get current partial assignment
    \State Sort remaining events by unassignment history, priority, and randomness
    \State Initialize unassigned events set
\\
    \For{each remaining event}
        \State FIND\_BEST\_ROOM\_AND\_PERIOD()
        \If{assignment found}
            \State Assign event to selected period and room
        \Else
            \State Mark event as unassigned
        \EndIf
    \EndFor
\\
    \State Evaluate overall timetable to compute hard and soft penalties
    \State Update global penalty trackers
\\
    \If{new solution improves global best}
        \State Save new best hard and soft penalties
        \State Write best assignment to output file
        \If{all events assigned and hard penalty is zero but soft is non-zero}
            \State HILL\_CLIMBING(...)
            \State Update global soft penalty
        \EndIf
    \EndIf
\\
    \State Normalize penalties
    \State \Return normalized hard and soft penalties
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Find Best Room and Period}\label{find_best_room_and_period}
\begin{algorithmic}[1]
\Function{FIND\_BEST\_ROOM\_AND\_PERIOD}{}
    \State Initialize \textit{min\_soft\_penalty} $\gets \infty$
    \State Initialize \textit{candidates} $\gets$ empty list
    \State Compute \textit{compactness\_weight} based on search depth
\\
    \For{each (weekday, timeslot) in event's available periods}
        \State FIND\_AVAILABLE\_ROOMS(...)
        \For{each available room}
            \State Compute \textit{hard\_penalty} for this assignment
            \If{\textit{hard\_penalty} $==$ 0}
                \State Compute \textit{soft\_penalty} as:
                \State \hspace{0.5cm} room capacity penalty
                \State \hspace{0.5cm} + compactness\_weight $\times$ compactness penalty
                \State \hspace{0.5cm} + minimum working days penalty
                \State \hspace{0.5cm} + room stability penalty
                \If{\textit{soft\_penalty} $<$ \textit{min\_soft\_penalty}}
                    \State Update \textit{min\_soft\_penalty}
                    \State Set \textit{candidates} to [(room, weekday, timeslot)]
                \ElsIf{\textit{soft\_penalty} $==$ \textit{min\_soft\_penalty}}
                    \State Add (room, weekday, timeslot) to \textit{candidates}
                \EndIf
            \EndIf
        \EndFor
    \EndFor
    \If{\textit{candidates} not empty}
        \State \Return random choice from \textit{candidates}
    \Else
        \State \Return None
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsubsection{Backpropagation}

The \(backpropagation\) phase (Algorithm \ref{backpropagation}) updates the path in the tree from the currently expanded node up to the root based on the simulation results. 

It starts from the current node, which is the leaf node where the simulation occurred, and moves up until reaching the root node. During this process, it performs updates for each node in the path, including incrementing the number of visits and updating the hard and soft scores with the simulation results. 

\begin{algorithm}
\caption{Backpropagation}\label{backpropagation}
\begin{algorithmic}[1]
\Procedure{BACKPROPAGATION}{simulation\_result\_hard, simulation\_result\_soft}
    \State Start at the current node
    \While{node is not None}
        \State Increment visit count
        \State Update hard score with simulation hard result
        \State Update soft score with simulation soft result
        \State Move to the parent node
    \EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Normalization}\label{sec:normalization}

The normalization equation \ref{normalization_formula} is applied to both hard and soft constraints to standardize the simulation results \cite{pedroso_tree_2015}:

\begin{equation}
N(n) = \frac{e^a - 1}{e - 1}, \quad \text{with } a = \frac{best\_penalty_n - worst\_penalty}{best\_penalty - worst\_penalty},\label{normalization_formula}
\end{equation}
where \(best\_penalty\) and \(worst\_penalty\) represent the best and the worst simulation results in the entire tree, and \(best\_penalty_n\) is the best simulation result under node \(n\).

This formulation ensures that the best simulation result is mapped to a value close to one, while the worst is mapped to zero.

\section{Hill climbing}\label{hill_climbing_section}

The\ac{hc} algorithm (Appendix \ref{AppendixA} Algorithm \ref{run_hill_climbing}) is applied as a local search method to further improve the timetable obtained from the\ac{mcts} simulation phase. This approach refines an initially feasible solution by iteratively exploring small modifications to enhance overall quality.

To maintain the structure established during the tree search,\ac{hc} only modifies events that are not assigned in the tree. This ensures that the global search strategy remains intact while improving suboptimally placed events by the simulation phase.

\subsection{Neighborhoods}

After finding a feasible solution with\ac{mcts},\ac{hc} refines the solution by exploring neighboring states. The algorithm explores the solution space using six different types of neighbors inspired by the\ac{itc-2007} track 3 winner \cite{muller_itc2007}:

\begin{itemize}
\item \textbf{Period move:} Change the timeslot and weekday of an event while keeping the same room.
\item \textbf{Room move:} Change the room of an event while keeping the same timeslot and weekday.
\item \textbf{Event move:} Change both the room and timeslot of an event.
\item \textbf{Room stability move:} Assign all events of the same course to the same room if possible.
\item \textbf{Compactness move:} Move an event to a timeslot adjacent to another event of the same curriculum.
\item \textbf{Minimum working days move:} Spread a course's events across more days to avoid teaching all lectures in a short period.
\end{itemize}

Each move has a weight, which affects how often it is chosen. Period, room and event moves appear to be the most effective, consequently they have a higher weight than the others.

\subsection{Methodology}

The\ac{hc} approach follows the following steps:

\begin{enumerate}
\item Starts with an initial complete timetable with no hard constraints violated.
\item Repeatedly selects a random neighborhood move, based on the assigned weights.
\item Applies the move and evaluates the new timetable.
\item If the new timetable is better, it keeps the changes; otherwise, it reverts them.
\item Stops when:
	\begin{itemize}
	\item A timetable satisfying all hard and soft constraints is found.
	\item No improvements are identified after a predefined number of idle iterations.
	\item The time limit is reached.
	\end{itemize}
\end{enumerate}

\begin{algorithm}
\caption{Hill Climbing}\label{run_hill_climbing}
\begin{algorithmic}[1]
\Function{HILL\_CLIMBING}{best\_timetable, start\_key, best\_result\_soft, start\_time, time\_limit}
    \State Define neighborhood moves with associated probabilities
    \State Initialize idle iteration counter
\\
    \While{within idle limit and time limit}
        \State Select a neighborhood move based on weighted probability
        \State Extract events not fixed in the tree (unscheduled events)
        \State Apply neighborhood move to generate a modified timetable
\\
        \If{no change was made}
            \State Increment idle counter and continue
        \EndIf
\\
	\State Evaluate the modified timetable
	\If{result improves best soft score}
                \State Update best soft score and best timetable
                \State Write updated result to file
                \If{soft penalty is zero}
                    \State \Return 0
                \EndIf
                \State Reset idle counter
            \Else
                \State Revert changes and increment idle counter
            \EndIf
        \Else
            \State Revert changes and increment idle counter
        \EndIf
    \EndWhile
\\
    \State \Return best soft result
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Diving}\label{sec:diving}

To improve the effectiveness of timetable generation, we also implemented a diving strategy in\ac{mcts} (Algorithm \ref{selection_with_diving} and \ref{diving_algorithm}). This diving strategy enables the algorithm to follow and deepen promising paths, aiming to improve the convergence speed and solution quality.

\begin{algorithm}
\caption{Selection with Diving}\label{selection_with_diving}
\begin{algorithmic}[1]
\Procedure{SELECTION}{}
	\If{queue is not empty}
		\State DIVE()
	\EndIf
\\
	\State ... 	\Comment{Perform standard\ac{mcts} traversal from the root}
	\\
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Dive}\label{diving_algorithm}
\begin{algorithmic}[1]
\Function{DIVE}{}
		\State \textit{selected\_node} $\gets$ Retrieve next node from the queue 
		\State \textit{simulation\_path} $\gets$ Retrieve associated simulation path
		\If{\textit{selected\_node} parent exists and is expandable}
            		\State Set \textit{selected\_node} to the parent
            		\State \Return True
            	\ElsIf{\textit{selected\_node} is fully expanded}
 			\State Follow the \textit{simulation\_path}:
			\For{each scheduled assignment in the path}
				\If{a child of the node matches the assignment}
					\State Set \textit{selected\_node} to this child
					\State Set current node to this child
					\State Remove the assignment from the \textit{simulation\_path}
					\State \Return True
				\EndIf
			\EndFor
		\Else
			\State Set current node to \textit{selected\_node}
               		\State \Return True
            	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Diving Approach Example}


\begin{figure}
      \centering
      \includegraphics[width=\columnwidth]{Development/MCTS_Diving.jpg}
      \caption[Diving approach]
      {Diving approach}
      \label{fig:diving}
\end{figure}


Figure \ref{fig:diving} illustrates the\ac{mcts} process using the diving strategy over six iterations. Initially, the algorithm begins with the root node and an empty queue. Whenever the queue is empty, the\ac{uct} formula is applied to select a child for expansion as described in \ref{sec:methodology}.

During the early\ac{mcts} iterations, child nodes \(A1\), \(A2\), and \(A3\) are sequentially added under the root. Each of these nodes undergoes a simulation that yields a penalty score. In this example, we assume that there are no hard constraint violations; hence, the score directly reflects the soft constraint penalty. 

While expanding the root, the algorithm tracks the node with the best simulation result and stores it in the queue, along with the corresponding complete timetable generated during the simulation. Therefore, in the first iteration, node \(A1\) produces the best score and is therefore added to the queue. In the second iteration, node \(A2\) does not outperform \(A1\), so the queue remains unchanged. However, once the root is fully expanded in the third iteration, node \(A3\) yields a better score than \(A1\), resulting in \(A1\) being replaced by \(A3\) in the queue. 

As a result, in the fourth iteration, node \(A3\) is the only element in the queue and, is directly selected for further expansion. This continues through the fifth iteration. During the expansion process, whenever a child node is found with a better simulation result than the current best, it is placed at the front of the queue. 

In the fifth iteration, although \(A3\) is fully expanded, none of its children surpass its score of -34. Therefore, the next node selected is \(B1\) because was part of the simulation path associated with \(A3\). Upon expanding \(B1\), the algorithm discovers node \(C1\), which yields a better score than the previous best from \(A3\). Consequently, \(C1\) is placed at the front of the queue.  

The expansion of \(B1\) continues, but once \(B1\) is fully expanded, the algorithm selects \(C1\) for expansion next, since it now holds the highest priority in the queue.
